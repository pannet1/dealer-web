import user
import pandas as pd
import pendulum
import concurrent.futures as cf

lst_dohlcv = ["dtime", "o", "h", "l", "c", "v"]
df_empty = pd.DataFrame()
dt = pendulum.yesterday()
fm = dt.set(hour=9, minute=14).to_datetime_string()[:-3]


def get_high(symboltoken, fm=20):
    try:
        ao = user.random_broker()
        param = {
            "exchange": "NSE",
            "symboltoken": symboltoken,
            "interval": "ONE_DAY",
            "fromdate": f"2023-03-{fm} 09:14",
            "todate": "2023-03-24 15:35",
        }
        resp = ao.obj.getCandleData(param)
        if resp.get('data'):
            return resp.get('data')[:-1][0][2]
        else:
            return 0
    except Exception as e:
        print(e)
        return 0


def get_ohlc(symboltoken, fm, to, tf):
    try:
        ao = user.random_broker()
        param = {
            "exchange": "NSE",
            "symboltoken": symboltoken,
            "interval": "ONE_MINUTE",
            "fromdate": fm,
            "todate": to,
        }
        resp = ao.obj.getCandleData(param)
        print(f"response is {resp.get('data')} for param \n {param}")
        if resp.get('data'):
            data = resp.get('data')
            df = pd.DataFrame(columns=lst_dohlcv, data=data)
            times = lst_dohlcv[0]
            df[times] = pd.to_datetime(df[times])
            df = df.set_index("dtime")
            print(df)
            dct = {
                "o": "first",
                "h": "max",
                "l": "min",
                "c": "last"
            }
            t = df.groupby(pd.Grouper(freq=tf)).agg(dct)
            lst_col = ["o", "h", "l", "c"]
            t.columns = lst_col
            t.reset_index(drop=True, inplace=True)
            t = t.loc[[0]]
            print(t)
            return t
        else:
            return df_empty
    except Exception as e:
        print(e)
        return df_empty


class Breakout:

    def __init__(self):
        pass

    def buy(self, *args, **kwargs):
        pass

    def sell(self, *args, **kwargs):
        pass

    def short(self, *args, **kwargs):
        pass

    def cover(self, *args, **kwargs):
        pass


class Equity:

    def __init__(self):
        user.contracts()
        self.df = pd.DataFrame()
        self.sleep = 1

    def set_symbols(self):
        lst_sym = ['SBIN-EQ', 'ITC-EQ']
        df = pd.DataFrame(columns=["symbol"], data=lst_sym)
        df['symboltoken'] = df.apply(user.get_token, axis=1)
        df['pdh'] = 0
        self.df = df

    def get_pdhs(self):
        df_cp = self.df.query("pdh==0")
        for i, row in df_cp.iterrows():
            self.df.loc[self.df.symbol == row.symbol,
                        "pdh"] = get_high(row.symboltoken, fm=22)

    def is_closed_above_yesterday_high(df, yesterday_high):
        if df['Close'][0] > yesterday_high:
            return True
        else:
            return False

    def is_any_candle_closed_above_1st_high(df):
        if df['High'][1:].max() > df['High'][0]:
            return True
        else:
            return False

    def is_range_within_1_percent(df):
        if (df['High'][0] - df['Low'][0]) / df['Low'][0] <= 0.01:
            return True
        else:
            return False

    def is_low_broken(df):
        if df['Low'][0] < df['Low'].min():
            return True
        else:
            return False

    def place_order(symbol, ohlc):
        df = pd.DataFrame.from_dict(ohlc)
        df['Datetime'] = pd.to_datetime(df['Datetime'], unit='ms')
        df.set_index('Datetime', inplace=True)
        yesterday_high = df['High'][-1]
        if len(df) == 5 and is_low_broken(df) and is_closed_above_yesterday_high(df, yesterday_high) and \
                not is_any_candle_closed_above_1st_high(df) and is_range_within_1_percent(df):
            entry_price = df['Low'][0]
            stop_loss = df['High'][0]
            target_price = entry_price - (entry_price - stop_loss) * 2
            print(
                f"Short trade order placed for {symbol} at {entry_price} with stop loss at {stop_loss} and target price at {target_price}")

    def scan_stocks(stocks, ohlc_data):
        with cf.ThreadPoolExecutor() as executor:
            for symbol in stocks:
                ohlc = ohlc_data.get(symbol)
                executor.submit(place_order, symbol, ohlc)


if __name__ == "__main__":
    ohlc_data = {
        'AAPL': {
            'Datetime': [1648434000000, 1648434300000, 1648434600000, 1648434900000, 1648435200000],
            'Open': [10.0, 10.1, 10.2, 10.3, 10.4],
            'High': [10.1, 10.2, 10.3, 10.4, 10.5],
            'Low': [9.9, 10.0, 10.1, 10.2, 10.3],
            'Close': [10.1, 10.2, 10.3, 10.4, 10.5]
        }
    }
    eqty = Equity()
    eqty.set_symbols()
    while eqty.sleep < 3:
        leng = eqty.df.query("pdh==0")
        print(leng)
        while not leng.empty and eqty.sleep < 3:
            eqty.get_pdhs()
            time = __import__("time")
            time.sleep(eqty.sleep)
            print(eqty.sleep)
            eqty.sleep += 1
        else:
            print(eqty.df)
            continue
    # SystemExit()
    eqty.sleep == 1

    to = dt.set(hour=9, minute=16).to_datetime_string()[:-3]
    df_ohlc = df_empty
    for i, row in eqty.df.iterrows():
        df = get_ohlc(row.symboltoken, fm, to, "1Min")
        df['symbol'] = row.symbol
        if df_ohlc.empty:
            df_ohlc = df
        else:
            df_ohlc = df_ohlc.append(df, ignore_index=True)

    df_ohlc = eqty.df.merge(df_ohlc, how="left", on=['symbol'])
    df_ohlc["lminuspdh"] = df_ohlc.eval("pdh - l")
    perc = 0.01
    str_eval = f"lminuspdh / l <={perc}"
    df_ohlc["1pct_rule"] = df_ohlc.eval(str_eval)
    print(df_ohlc)
